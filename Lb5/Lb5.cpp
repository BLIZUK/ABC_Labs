// Лабораторная работа номер 5
// Подпрограммы преобразования


/*
	~Набросок~

										** Структура:	
	
	|-------------------------------------------------------------------------------------------|
	|* Вход (main) -> Выбор режим перевода -> Ввод числа -> asm вставка -> Вывод числа в консоль|
	|-------------------------------------------------------------------------------------------|
	|																						    |
	|						  							   main()							    |
	|					 (Выбор режима перевода числа <------|-----> Выход из программы)	    |
	|								 	|								   |				    |
	|						     |While flag > 0|				 | EXIT if flag == 0 |		    |
	|									 |														|
	|	------------------------------------------------------------------						|
	|	|			|					 |					   |		 |						|
	|	|	  |flag == 1|			|flag == 2|           |flag == 3|	 |						|
	|	|			|					 |					   |		 |						|
	|	|	  DEC_to_HEX()  <----> 	DEC_to_BIN()  <---->  DEC_to_OCT()   |						|  
	|	|	   (10 -> 16)			 (10 -> 2)			   (10 -> 8)	 |						|
	|	|			|					 |                     |		 |						|
	|	|			|					 |					   |		 |						|
	|	------------------------------------------------------------------						|
	|-------------------------------------------------------------------------------------------|

	*/

#include <iostream>
#include <string>


using namespace std;


// Вывод названия работы
void nameLb() {
	cout << "-----------------------------------------------------------------" << endl;
	cout << "|\t\t Лабораторная работа номер 5.\t\t\t|\n|\t\t'Подпрограммы преобразования'\t\t\t|" << endl;
	cout << "-----------------------------------------------------------------" << endl;
}


// Перевод числа в аски формат с помощью C++
void string_to_ascii(const string& input_string) 
{
	for (char c : input_string) {
		cout << static_cast<int>(c) << " ";
	}
	cout << std::endl;
}


// Перевод числа в аски формат через ассемблер
void string_to_askii_ass(string& txt, int index) {
	char symb;
	int check;
	for (int i = 0; i < index; i++) {
		symb = txt[i];

		__asm {
			mov al, symb
			movzx eax, al
			mov check, eax

		}

		cout << check << " ";
	}
}


// Функция для перевода десятичного числа в шестнадцатеричное число
void DEC_to_HEX() 
{
	unsigned int number;
	char hexStr[9] = "00000000"; // 8 символов + 1 для нуль-терминатора
	nameLb();
	cout << "     Перевод числа из десятичного формата в шестнадцатеричный.\n\t\t\t  {10->16}\n"<< endl;
		cout << "|x| Введите целое число:\n\n$->: ";
		cin >> number;
		__asm
		{
			mov eax, number; // Загружаем десятичное число в регистр EAX
			lea edi, hexStr; // Загружаем адрес массива hexString в регистр EDI
			add edi, 7;		 // Устанавливаем EDI на последний символ массива
			mov ecx, 8;		 // Счетчик на 8 символов

		Converter:
			mov edx, eax;	 // Копируем значение EAX в EDX
			and edx, 0Fh;	 // Извлекаем младшие 4 бита (одну шестнадцатеричную цифру)
			add dl, '0';	 // Преобразуем в символ ASCII
			cmp dl, '9';	 // Проверяем, если значение больше '9'
			jbe Check
				add dl, 7;	 // Если больше '9', корректируем до буквы ('A' - 'F')
		Check:
			mov[edi], dl;	 // Записываем символ в строку
			dec edi;		 // Переходим к следующему символу справа
			shr eax, 4;		 // Сдвигаем EAX на 4 бита вправо
			loop Converter;  // Повторяем цикл
		}

		char  zero_data;
		string result = "";
		int flag = 0;

		for (int i = 0; i < 8; i++) {
			if (hexStr[i] != '0') 
			{
				flag = 1;
			}
			if (flag == 1) {
				result += hexStr[i];
			}
		}

		cout << "\n|!| Ответ: \n" << "\n--> Шестнадцатеричный формат - " <<  result << endl;
		cout << "--> ASKII формат:\n----> Кодировка: ";
		int len = result.length();
		//string_to_ascii(result);
		string_to_askii_ass(result, len);
		cout << "\n----> Символ: '" << result << "'";
		cout << "\n\n|x| Введите любую клавишу, что бы продолжить...\n\n$->:";
		cin >> zero_data;
		system("cls");
	}


// Функция для перевода десятичного числа в двоичное число
void DEC_to_BIN()
{
	int number;
	char binaryStr[33]; // 32 бита + 1 для нуль-терминатора
	nameLb();
	cout << "     Перевод числа из десятичного формата в двоичный.\n\t\t\t  {10->2}\n" << endl;
	cout << "|x| Введите целое число:\n\n$->: ";
		cin >> number;

		__asm {
			mov eax, number             // Загружаем число в регистр eax
			lea edi, binaryStr		    // Указатель на начало массива для записи
			xor ecx, ecx                // Обнуляем ecx (используется как счетчик)

			convert_loop :
			shl eax, 1                  // Сдвигаем число влево на 1 бит
				jc set_one                  // Если установлен бит, записываем '1'
				mov byte ptr[edi], '0'      // Иначе записываем '0'
				jmp next_bit                // Переходим к следующему биту

				set_one :
			mov byte ptr[edi], '1'      // Записываем '1'

				next_bit :
				inc edi                     // Сдвигаем указатель вправо
				inc ecx                     // Увеличиваем счетчик
				cmp ecx, 32                 // Проверяем, достигли ли 32 бит
				jl convert_loop             // Если нет, продолжаем

		}

		char  zero_data;
		string result = "";
		int flag = 0;

		for (int i = 0; i < 32; i++) {
			if (binaryStr[i] != '0')
			{
				flag = 1;
			}
			if (flag == 1) {
				result += binaryStr[i];
			}
		}

		cout << "\n|!| Ответ: \n" << "\n--> Двоичный формат - " << result << endl;
		cout << "--> ASKII формат:\n----> Кодировка: ";
		int len = result.length();
		//string_to_ascii(result);
		string_to_askii_ass(result, len);
		cout << "\n----> Символ: '" << result << "'";
		cout << "\n\n|x| Введите любую клавишу, что бы продолжить...\n\n$->:";
		cin >> zero_data;
		system("cls");
	}


// Функция для перевода десятичного числа в восмеричное число
void DEC_to_OCT()
{
	unsigned int number;
	char octStr[12] = "00000000000"; // 11 символов + 1 для нулевого символа
	int index = 11;
	octStr[index] = '\0';

	nameLb();
	cout << "     Перевод числа из десятичного формата в восмеричный.\n\t\t\t  {10->8}\n" << endl;
	cout << "|x| Введите целое число:\n\n$->: ";

	cin >> number;
	__asm
	{
		mov eax, number     // Загружаем десятичное число в регистр EAX
		mov ecx, index          // Загружаем индекс в регистр ECX

		cmp eax, 0              // Проверяем, равно ли число 0
		je special_case         // Если равно 0, переходим к специальному случаю

		convert_loop :
		xor edx, edx            // Обнуляем EDX перед делением
			mov ebx, 8              // Устанавливаем основание 8 для деления
			div ebx                  // Делим EAX на 8, остаток в EDX, частное в EAX
			add dl, '0'             // Преобразуем остаток в символ ASCII
			dec ecx                 // Уменьшаем индекс
			mov[octStr + ecx], dl // Записываем символ в массив
			test eax, eax           // Проверяем, не стало ли число нулевым
			jnz convert_loop        // Если не ноль, продолжаем цикл
			jmp finish              // Переходим к завершению

			special_case :
		mov byte ptr[octStr + 10], '0' // Специальный случай для 0
			dec ecx                 // Уменьшаем индекс

			finish :
		mov index, ecx          // Сохраняем индекс для создания строки
	}

	char  zero_data;
	string result = "";
	int flag = 0;

	for (int i = 0; i < 12; i++) {
		if (octStr[i] != '0')
		{
			flag = 1;
		}
		if (flag == 1) {
			result += octStr[i];
		}
	}

	cout << "\n|!| Ответ: \n" << "\n--> Восмеричный формат - " << result << endl;
	cout << "--> ASKII формат:\n----> Кодировка: ";
	int len = result.length();
	string_to_askii_ass(result, len);
	cout << "\n----> Символ: '" << result << "'";
	cout << "\n\n|x| Введите любую клавишу, что бы продолжить...\n\n$->:";
	cin >> zero_data;
	system("cls");
}


// Функция для вывода информации об лабораторной работы
void info()
{
	char zero_data;
	cout << "------------------------------------------------------------------------------------------------------------------------" << endl;
	cout << "|\n|\t\t\t\t\t\tРабочее задание\n|" << endl;
	cout << "|\t1. Ввести и отладить программу на ассемблере перевода целого числа (unsigned integer) в формат ASCII \n|  как HEX числа. Для ввода исходных данных и вывода результата использовать операторы С++." << endl;
	cout << "|\t2. Отладить аналогично программы перевода в формат ASCII в двоичной и восьмеричной форме представления " << endl;
	cout << "|\t3. Организовать процедуры преобразований форматов в форме подпрограмм. Предусмотреть задание типа преобразования" << endl;
	cout << "|  в виде меню на С++, а в ассемблерной вставке организовать выбор и выполнение преобразования во варианту " << endl;
	cout << "|  заданному в меню (по номеру в меню). Предусмотреть повторное выполнение процедуры преобразования и завершение" << endl;
	cout << "|  работыпо выбору в меню строки EXIT.\n|" << endl;
	cout << "------------------------------------------------------------------------------------------------------------------------" << endl;
	cout << "\n|x| Введите любую клавишу, что бы продолжить...\n\n$->:";
	cin >> zero_data;
	system("cls");
}


// Точка входа
int main() 
{
	system("chcp 1251 > nul");
	
	int flagAction, flagFormat;

	// Первое меню
	// 1 ---------
	do 
	{
		nameLb();

		cout << "\t\t\tГлавное меню." << endl;
		cout << "\n|x| Выбор действия:\n\n0 - Выход; \n1 - Действие с данными; \n2 - Техническое задание;\n\n$->: ";
		cin >> flagAction;

		// Начало обработки первого меню
		// START 1 ---------------------
		switch (flagAction)
		{
		case 1:
			system("cls");
			
			// Второе меню
			// 2 ---------
			do
			{
				nameLb();

				cout << "\t\t    Меню обработки данных." << endl;
				cout << "\n|x| Выберите необходимый формат данных:\n\n0 - Выход в главное меню; \n1 - Шестнадцатеричный; \n2 - Двоичный; \n3 - Восмеричный;\n\n$->: ";
				cin >> flagFormat;

				// Начало обработки второго меню
				// START 2 ---------------------
				switch (flagFormat)
				{
				case 1:
					system("cls");
					DEC_to_HEX();
					break;
				case 2:
					system("cls");
					DEC_to_BIN();
					break;
				case 3:
					system("cls");
					DEC_to_OCT();
					break;
				}
				system("cls");
				if (flagFormat < 0 || flagFormat > 3) cout << "\n|!| Вы ввели неверное значение!\n" << endl;
				
			} while (flagFormat != 0);
			// Конец второго меню
			// END 2 ------------
			break;
		case 2:
			system("cls");
			info();
			break;
		}
		system("cls");
		if (flagAction < 0 || flagAction > 2) cout << "\n|!| Вы ввели неверное значение!\n" << endl;
	} while (flagAction != 0);
	// Конец первого меню
	// END 1 ------------

	cout << "\n|!| Завершение работы!" << endl;
	return 0;
}
